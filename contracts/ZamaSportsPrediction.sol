// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Encrypted sports prediction contract powered by Zama FHE
contract ZamaSportsPrediction is SepoliaConfig {
    struct Prediction {
        string title;
        string homeTeam;
        string awayTeam;
        address creator;
        bool isActive;
        euint32 homeVotes;
        euint32 awayVotes;
        euint32 drawVotes;
    }

    event PredictionCreated(
        uint256 indexed predictionId,
        address indexed creator,
        string title,
        string homeTeam,
        string awayTeam
    );

    event PredictionVoted(uint256 indexed predictionId, address indexed voter);

    event PredictionClosed(uint256 indexed predictionId, address indexed closer);

    Prediction[] private _predictions;
    mapping(uint256 => mapping(address => bool)) private _hasPredicted;

    error InvalidPrediction(uint256 predictionId);
    error PredictionInactive(uint256 predictionId);
    error AlreadyPredicted(uint256 predictionId, address account);

    /// @notice Creates a new prediction entry
    /// @param title The prediction title
    /// @param homeTeam The name of the home team
    /// @param awayTeam The name of the away team
    /// @return predictionId The identifier of the newly created prediction
    function createPrediction(string memory title, string memory homeTeam, string memory awayTeam)
        external
        returns (uint256 predictionId)
    {
        require(bytes(title).length > 0, "Empty title");
        require(bytes(homeTeam).length > 0, "Empty home team");
        require(bytes(awayTeam).length > 0, "Empty away team");

        predictionId = _predictions.length;
        _predictions.push();
        Prediction storage prediction = _predictions[predictionId];
        prediction.title = title;
        prediction.homeTeam = homeTeam;
        prediction.awayTeam = awayTeam;
        prediction.creator = msg.sender;
        prediction.isActive = true;

        emit PredictionCreated(predictionId, msg.sender, title, homeTeam, awayTeam);
    }

    /// @notice Records an encrypted vote for a prediction
    /// @param predictionId The identifier of the prediction to vote on
    /// @param homeVoteHandle Encrypted selection for the home team option (1 for selected, 0 otherwise)
    /// @param awayVoteHandle Encrypted selection for the away team option
    /// @param drawVoteHandle Encrypted selection for the draw option
    /// @param inputProof The input proof generated by the relayer SDK
    function submitPrediction(
        uint256 predictionId,
        externalEuint32 homeVoteHandle,
        externalEuint32 awayVoteHandle,
        externalEuint32 drawVoteHandle,
        bytes calldata inputProof
    ) external {
        if (predictionId >= _predictions.length) {
            revert InvalidPrediction(predictionId);
        }

        Prediction storage prediction = _predictions[predictionId];
        if (!prediction.isActive) {
            revert PredictionInactive(predictionId);
        }

        if (_hasPredicted[predictionId][msg.sender]) {
            revert AlreadyPredicted(predictionId, msg.sender);
        }

        euint32 homeVote = FHE.fromExternal(homeVoteHandle, inputProof);
        euint32 awayVote = FHE.fromExternal(awayVoteHandle, inputProof);
        euint32 drawVote = FHE.fromExternal(drawVoteHandle, inputProof);

        prediction.homeVotes = FHE.add(prediction.homeVotes, homeVote);
        prediction.awayVotes = FHE.add(prediction.awayVotes, awayVote);
        prediction.drawVotes = FHE.add(prediction.drawVotes, drawVote);

        _hasPredicted[predictionId][msg.sender] = true;

        FHE.allowThis(prediction.homeVotes);
        FHE.allowThis(prediction.awayVotes);
        FHE.allowThis(prediction.drawVotes);

        emit PredictionVoted(predictionId, msg.sender);
    }

    /// @notice Closes an active prediction and grants the caller access to decrypt the totals
    /// @param predictionId The identifier of the prediction to close
    function closePrediction(uint256 predictionId) external {
        if (predictionId >= _predictions.length) {
            revert InvalidPrediction(predictionId);
        }

        Prediction storage prediction = _predictions[predictionId];
        if (!prediction.isActive) {
            revert PredictionInactive(predictionId);
        }

        prediction.isActive = false;

        FHE.allow(prediction.homeVotes, msg.sender);
        FHE.allow(prediction.awayVotes, msg.sender);
        FHE.allow(prediction.drawVotes, msg.sender);

        emit PredictionClosed(predictionId, msg.sender);
    }

    /// @notice Returns information about a prediction
    /// @param predictionId The identifier of the prediction to fetch
    /// @return title The prediction title
    /// @return homeTeam The home team name
    /// @return awayTeam The away team name
    /// @return creator The prediction creator address
    /// @return isActive Whether the prediction is active
    /// @return homeVotes The encrypted vote counter for the home team
    /// @return awayVotes The encrypted vote counter for the away team
    /// @return drawVotes The encrypted vote counter for the draw option
    function getPrediction(uint256 predictionId)
        external
        view
        returns (
            string memory title,
            string memory homeTeam,
            string memory awayTeam,
            address creator,
            bool isActive,
            euint32 homeVotes,
            euint32 awayVotes,
            euint32 drawVotes
        )
    {
        if (predictionId >= _predictions.length) {
            revert InvalidPrediction(predictionId);
        }

        Prediction storage prediction = _predictions[predictionId];
        return (
            prediction.title,
            prediction.homeTeam,
            prediction.awayTeam,
            prediction.creator,
            prediction.isActive,
            prediction.homeVotes,
            prediction.awayVotes,
            prediction.drawVotes
        );
    }

    /// @notice Returns whether an account has already submitted a prediction
    /// @param predictionId The identifier of the prediction to check
    /// @param account The account to validate
    /// @return predicted True if the account has already predicted
    function hasPredicted(uint256 predictionId, address account) external view returns (bool predicted) {
        if (predictionId >= _predictions.length) {
            revert InvalidPrediction(predictionId);
        }

        predicted = _hasPredicted[predictionId][account];
    }

    /// @notice Returns the number of predictions that exist
    /// @return count The total number of predictions
    function getPredictionCount() external view returns (uint256 count) {
        count = _predictions.length;
    }
}
